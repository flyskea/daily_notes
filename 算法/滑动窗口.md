滑动窗口（Sliding Window）是一种用于解决数组/字符串相关问题的常见技巧，通过维护一个大小可以伸缩的窗口来执行具体操作，随着窗口在数组/字符串上移动，根据窗口的变化来执行具体的操作。

滑动窗口算法执行的基本步骤:

1. 初始化左指针 left 和右指针 right，并且初始化结果变量
2. 移动右指针，**扩大窗口大小**，直到满足特定条件 (窗口内的元素满足某种条件 或 达到数组/字符串的末尾)
3. 移动左指针，**缩小窗口大小** (直到不再满足特定条件) **同时更新结果变量**.
4. 重复步骤 2 和 3，直到右指针达到数组/字符串的末尾

# [209. 长度最小的子数组](https://leetcode.cn/problems/minimum-size-subarray-sum/description/)


给定一个含有 `n` 个正整数的数组和一个正整数 `target` **。**

找出该数组中满足其总和大于等于 `target` 的长度最小的 **子数组** `[numsl, numsl+1, ..., numsr-1, numsr]` ，并返回其长度**。**如果不存在符合条件的子数组，返回 `0` 。

> **输入：** target = 7, nums = [2,3,1,2,4,3]
> **输出：** 2
> **解释：** 子数组 `[4,3]` 是该条件下的长度最小的子数组。

## 思路

1. 初始化左指针 left 和右指针 right，并且初始化结果最小长度
2. 移动右指针，**扩大窗口大小**，直到满足特定条件 (窗口内的元素和大于等于目标参数 或 达到数组的末尾)
3. 移动左指针，**缩小窗口大小** (窗口内的元素和小于目标参数) **同时更新结果变量**.

## 代码实现

```go
func minSubArrayLen(target int, nums []int) int {
	// 初始化最小长度为数组长度 + 1
	minLen := len(nums) + 1
	sum, left := 0, 0

	// 移动右指针
	for right := range nums {
		sum += nums[right]

		// 找到符合条件的子数组时，开始收缩窗口大小
		for sum >= target {
			minLen = min(minLen, right-left+1)
			sum -= nums[left]
			left++
		}
	}

	// 如果最小长度依然等于数组长度 + 1
	// 说明数组中不存在符合条件的子数组
	if minLen > len(nums) {
		return 0
	}
	return minLen
}

func min(x, y int) int {
	if x < y {
		return x
	}
	return y
}
```

```rust
impl Solution {
    pub fn min_sub_array_len(target: i32, nums: Vec<i32>) -> i32 {
        let mut ans = (nums.len() + 1) as i32;
        let mut left = 0;
        let mut right = 0;
        let mut sum = 0;

        while right < nums.len() {
            sum += nums[right];
            while sum >= target {
                ans = ans.min((right - left + 1) as i32);
                sum -= nums[left];
                left += 1;
            }
            right += 1;
        }

        if ans > nums.len() as i32 {
            0
        } else {
            ans
        }
    }
}
```

# [3. 无重复字符的最长子串](https://leetcode.cn/problems/longest-substring-without-repeating-characters/description/)

给定一个字符串 `s` ，请你找出其中不含有重复字符的 **最长子串** 的长度。

> **输入**: s = "abcabcbb"
> **输出**: 3 
> **解释**: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
## 思路

1. 初始化左指针 left 和右指针 right，并且初始化结果最小长度，同时维护一个 Map 作为窗口内的重复字符检测
2. 移动右指针，**扩大窗口大小**，直到满足特定条件 (窗口内的元素出现重复 或 达到字符串的末尾)
3. 移动左指针，**缩小窗口大小** (窗口内的元素没有重复) **同时更新结果变量**.

## 代码实现

```go
func lengthOfLongestSubstring(s string) int {
	// 题目声明字符串 s 由英文字母、数字、符号和空格组成
	// 所以这里使用一个长度为 256 的数组来模拟 Map 功能
	var win [256]int
	res, n := 0, len(s)

	// 声明左右指针
	for left, right := 0, 0; right < n; right++ {
		c := s[right]
		// 更新窗口
		win[c]++

		// 遇到重复的字符时，开始收缩窗口大小
		for win[c] > 1 {
			win[s[left]]--
			left++
		}

		// 更新已知的最大窗口
		res = max(res, right-left+1)
	}

	return res
}
```

```rust
impl Solution {
    pub fn length_of_longest_substring(s: String) -> i32 {
    
        let mut win = vec![0; 256];
        let (mut res, mut left) = (0, 0);
        let n = s.len();
        let s_chars: Vec<char> = s.chars().collect();

        for right in 0..n {
            let c = s_chars[right] as usize;
            win[c] += 1;

            while win[c] > 1 {
                let left_char = s_chars[left] as usize;
                win[left_char] -= 1;
                left += 1;
            }

            res = res.max((right - left + 1) as i32);
        }

        res
    }
}
```

# [424. 替换后的最长重复字符](https://leetcode.cn/problems/longest-repeating-character-replacement/description/)

给你一个字符串 `s` 和一个整数 `k` 。你可以选择字符串中的任一字符，并将其更改为任何其他大写英文字符。该操作最多可执行 `k` 次。

在执行上述操作后，返回 _包含相同字母的最长子字符串的长度。_

**示例 1：**

> **输入：** s = "ABAB", k = 2
> **输出：** 4
> **解释：** 用两个'A'替换为两个'B',反之亦然。

**示例 2：**

> **输入：** s = "AABABBA", k = 1
> **输出：** 4
> **解释：**
> 将中间的一个'A'替换为'B',字符串变为 "AABBBBA"。
> 子串 "BBBB" 有最长重复字母, 答案为 4。
> 可能存在其他的方法来得到同样的结果。

## 思路

- **初始化**：初始化左指针 `left` 和右指针 `right`，结果变量 `ans` 初始化为0，同时维护一个 `cntMap` 作为窗口内的字符计数。
- **移动右指针，扩大窗口大小**：右指针逐步扩展窗口，遍历字符串，并更新 `cntMap` 中当前字符的出现次数及 `maxCnt` 为窗口内出现最多的单个字符的次数。如果窗口长度（`right - left + 1`）减去 `maxCnt` 大于 `k`，则当前窗口内需要替换的字符数超过 `k` 个，不满足条件，需要通过移动左指针缩小窗口，并更新 `cntMap` 中 `left` 所指字符的次数。
- **移动左指针，缩小窗口大小**：当窗口不满足条件时（即窗口内需要替换的字符数超过 `k` 个），左指针移动，缩小窗口，更新 `cntMap` 中 `left` 所指字符的次数。如果左边界移除以后，使得此时 `maxCnt` 的值变小，又由于我们要找的只是最长替换 k 次以后重复子串的长度。接下来我们继续让右边界向右移动一格，有两种情况：① 右边界如果读到了刚才移出左边界的字符，恰好 `maxCnt` 的值被正确维护；② 右边界如果读到了不是刚才移出左边界的字符，新的子串要想在符合题意的条件下变得更长，`maxCnt` 一定要比之前的值还要更多，因此不会错过更优的解。
- **更新结果变量**：每次调整窗口后，计算当前窗口长度，如果当前窗口长度大于 `ans`，则更新 `ans`。

## 代码实现

```go
func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}

func characterReplacement(s string, k int) int {
	var (
		left, right, ans, maxCnt int
	)
	cntMap := map[byte]int{}

	for right < len(s) {
		cntMap[s[right]]++
		maxCnt = max(maxCnt, cntMap[s[right]])
		if right-left+1-maxCnt > k {
			cntMap[s[left]]--
			left++
			right++
		} else {
			tmp := right - left + 1
			if tmp > ans {
				ans = tmp
			}
			right++
		}
	}

	return ans
}
```

```rust
impl Solution {
    fn character_replacement(s: String, k: i32) -> i32 {
        let s = s.as_bytes();
        let mut left = 0;
        let mut right = 0;
        let mut ans = 0;
        let mut max_cnt = 0;
        let mut cnt_map: HashMap<u8, i32> = HashMap::new();

        while right < s.len() {
            let count = cnt_map.entry(s[right]).or_insert(0);
            *count += 1;
            max_cnt = max_cnt.max(*count);

            if (right - left + 1) as i32 - max_cnt > k {
                let left_count = cnt_map.entry(s[left]).or_insert(0);
                *left_count -= 1;
                left += 1;
            }
            right += 1;
            ans = ans.max((right - left) as i32);
        }

        ans
    }
}
```

# [567. 字符串的排列](https://leetcode.cn/problems/permutation-in-string/description/)

给你两个字符串 `s1` 和 `s2` ，写一个函数来判断 `s2` 是否包含 `s1` 的排列。如果是，返回 `true` ；否则，返回 `false` 。

换句话说，`s1` 的排列之一是 `s2` 的 **子串** 。

示例 1：

> **输入**：s 1 = "ab" s 2 = "eidbaooo"
> **输出**：true
> **解释**：s 2 包含 s 1 的排列之一 ("ba").

示例 2：

> **输入**：s 1= "ab" s 2 = "eidboaoo"
> **输出**：false

## 思路

将s2的哈希初始为和s1相同，right遍历时将字符逐个从s2的哈希里减掉，如果减为负数说明不复合要求则移动left直到符合要求。当存在right-left+1与s1长度相等时即为true，否则为false。

## 代码实现

```go
func checkInclusion(s1 string, s2 string) bool {
    n := len(s1)
    a1 := make([]int, 26)
    for _, c := range s1 {
        a1[c-'a']++
    }
    
    left, right := 0, 0
    a2 := make([]int, 26)
    copy(a2, a1)
    
    for right < len(s2) {
        a2[s2[right]-'a']--
        for a2[s2[right]-'a'] < 0 {
            a2[s2[left]-'a']++
            left++
        }
        if n == right-left+1 {
            return true
        }
        right++
    }
    
    return false
}
```

# [239. 滑动窗口最大值](https://leetcode.cn/problems/sliding-window-maximum/description/)

给你一个整数数组 `nums`，有一个大小为 `k` 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 `k` 个数字。滑动窗口每次只向右移动一位。

返回 _滑动窗口中的最大值_ 。

> **输入：** nums = [1,3,-1,-3,5,3,6,7], k = 3
> **输出：** [3,3,5,5,6,7]
> **解释：**

| 滑动窗口的位置               <br> | 最大值   |
| -------------------------- | ----- |
| [1  3  -1] -3  5  3  6  7  | **3** |
| 1 [3  -1  -3] 5  3  6  7   | **3** |
| 1  3 [-1  -3  5] 3  6  7   | 5     |
| 1  3  -1 [-3  5  3] 6  7   | 5     |
| 1  3  -1  -3 [5  3  6] 7   | 6     |
| 1  3  -1  -3  5 [3  6  7]  | 7     |

## 思路

- **初始化：** 初始化一个双端队列 `deque`，结果数组 `ans`，左指针 `left` 和右指针 `right` 均设置为0。双端队列用于存储窗口中元素的下标，并且保证队列中的元素从大到小排列。
- **移动右指针，扩大窗口大小：** 右指针逐步扩展窗口，遍历数组 `nums`。对于每个新元素 `nums[right]`，在 `deque` 的尾部删除所有小于该元素的元素的下标，因为这些元素不会再影响窗口的最大值。然后，将 `right` 的下标添加到 `deque` 的尾部。
- **移动左指针，缩小窗口大小：** 当窗口的大小大于或等于 `k` 时，左指针开始移动。如果 `deque` 头部元素等于 `left`，则将 `deque` 头部元素删除。然后将 `left` 右移一位。
- **更新结果数组：** 每当窗口的大小达到 `k` 时，将 `deque` 头部元素（即当前窗口的最大值的下标）对应的值添加到结果数组 `ans` 中。

## 代码实现

```go
func maxSlidingWindow(nums []int, k int) []int {
    if len(nums) == 0 || k == 0 {
        return []int{}
    }

    var res []int
    var deque []int

    for i := 0; i < len(nums); i++ {
        // 移除超过窗口的元素
        if len(deque) > 0 && deque[0] < i-k+1 {
            deque = deque[1:]
        }

        // 移除不必要元素
        for len(deque) > 0 && nums[deque[len(deque)-1]] < nums[i] {
            deque = deque[:len(deque)-1]
        }

        // 添加当前元素
        deque = append(deque, i)

        // 达到窗口，记录最大值
        if i >= k-1 {
            res = append(res, nums[deque[0]])
        }
    }

    return res
}
```

# [76. 最小覆盖子串](https://leetcode.cn/problems/minimum-window-substring/description/)

给你一个字符串 `s` 、一个字符串 `t` 。返回 `s` 中涵盖 `t` 所有字符的最小子串。如果 `s` 中不存在涵盖 `t` 所有字符的子串，则返回空字符串 `""` 。

> **输入：** s = "ADOBECODEBANC", t = "ABC"
> **输出：** "BANC"
> **解释：** 最小覆盖子串 "BANC" 包含来自字符串 t 的 'A'、'B' 和 'C'。

## 思路

- **初始化：** 初始化左右指针 `left` 和 `right` 为 0，记录结果的变量 `minLen` 为一个大值，结果的起始位置 `start` 为 0。同时，使用两个哈希表 `tMap` 和 `windowMap` 分别记录字符串 `t` 中的字符计数和当前窗口内的字符计数。
    
- **统计目标字符串 `t` 中的字符：** 遍历字符串 `t`，统计每个字符的出现次数，并记录在 `tMap` 中。
    
- **移动右指针，扩大窗口大小：** 右指针逐步扩展窗口，遍历字符串 `s`。将当前字符 `s[right]` 加入到 `windowMap` 中，并更新其计数。
    
- **检查窗口是否包含所有目标字符：** 当当前窗口内包含所有目标字符时（即窗口内每个目标字符的出现次数都不小于 `tMap` 中的相应计数），尝试缩小窗口：
    - 移动左指针 `left`，直到窗口不再包含所有目标字符。
    - 在缩小窗口的过程中，记录满足条件的最小窗口大小和起始位置。
- **更新结果：** 如果找到比之前记录的更小的符合条件的窗口，更新 `minLen` 和 `start`。
    
- **返回结果：** 根据记录的最小窗口长度 `minLen` 和起始位置 `start`，从字符串 `s` 中提取相应的子串作为结果返回。如果 `minLen` 仍为初始值，表示没有符合条件的子串，返回空字符串 `""`。

## 代码实现

```go
func minWindow(s string, t string) string {
	chars := make([]int, 128)
	flag := make([]bool, 128)
	for i := range t {
		flag[t[i]] = true
		chars[t[i]]++
	}
	var cnt, l, minL, minSize int
	minSize = len(s) + 1
	for r := 0; r < len(s); r++ {
		if flag[s[r]] {
			chars[s[r]]--
			if chars[s[r]] >= 0 {
				cnt++
			}
			for cnt == len(t) {
				if r-l+1 < minSize {
					minL = l
					minSize = r - l + 1
				}
				if flag[s[l]] {
					chars[s[l]]++
					if chars[s[l]] > 0 {
						cnt--
					}
				}
				l++
			}
		}
	}
	if minSize > len(s) {
		return ""
	}
	return s[minL : minL+minSize]
}
```